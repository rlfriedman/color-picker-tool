{"version":3,"sources":["images/sunset.jpg","images/flowers.jpg","images/parrots.jpg","images/island.jpg","logo.svg","App.js","serviceWorker.js","index.js"],"names":["module","exports","__webpack_require__","p","images","sunset","flowers","parrots","island","App","state","imageUrl","colorSwabs","currentImageIndex","color","hex","tempHex","currentSwab","totalSwabs","maxSwabs","isActive","textFieldValue","_this2","this","react_default","a","createElement","className","App_ImageCanvas","colorMove","pixel","handleColorMove","colorSelected","handleColorSelected","handleImageLoaded","updateImageUrlParam","App_ColorPalette","handleSwabClick","swabIndex","react_text_field_dist_default","outlined","dense","label","react_text_field_dist","value","onKeyPress","e","handleInputKeypress","onChange","setState","target","dist_default","onClick","length","resetPallete","navigator","clipboard","writeText","window","location","href","prevProps","prevState","url","URL","searchParams","get","decodeURIComponent","palleteParams","paletteColors","i","param","push","set","encodeURIComponent","history","replaceState","path","toString","substring","key","pathname","rgbToHex","activeSwab","addColorToUrl","newSwabs","slice","index","Component","ImageCanvas","canvasElement","React","createRef","updateImage","props","_this4","current","ctx","getContext","image","Image","onload","clearRect","width","height","_resizeImageToFitCanv","canvas","parentWidth","parentHeight","childWidth","childHeight","childRatio","offsetX","offsetY","resizeImageToFitCanvas","drawImage","onerror","alert","crossOrigin","src","getColorFromMouseEvent","rect","getBoundingClientRect","x","clientX","left","y","clientY","top","getImageData","data","_this5","onMouseMove","handleMouseMove","handleClick","ref","ColorPalette","colorSwabEl","updateColor","temp","_this7","swabs","empty","RippleColorSwab","id","ColorSwab","initRipple","style","backgroundColor","_this9","_this$props","_this$props$className","otherProps","unbounded","Object","objectWithoutProperties","classes","concat","assign","withRipple","imageData","Boolean","hostname","match","ReactDOM","render","src_App_0","document","getElementById","serviceWorker","ready","then","registration","unregister"],"mappings":"4EAAAA,EAAAC,QAAiBC,EAAAC,EAAuB,uDCAxCH,EAAAC,QAAiBC,EAAAC,EAAuB,wDCAxCH,EAAAC,QAAiBC,EAAAC,EAAuB,wDCAxCH,EAAAC,QAAiBC,EAAAC,EAAuB,gHCAxCH,EAAAC,QAAiBC,EAAAC,EAAuB,mTCclCC,qBAAS,CAACC,IAAQC,IAASC,IAASC,MAEpCC,6MACJC,MAAQ,CACNC,SAAUP,EAAO,GACjBQ,WAAY,CAAC,SACbC,kBAAmB,EACnBC,MAAO,KACPC,IAAK,KACLC,QAAS,KACTC,YAAa,EACbC,WAAY,EACZC,SAAU,EACVC,UAAU,EACVC,eAAgB,4EAGT,IAAAC,EAAAC,KACP,OACEC,EAAAC,EAAAC,cAAA,OAAKC,UAAU,iBACbH,EAAAC,EAAAC,cAAA,OAAKC,UAAU,wBACbH,EAAAC,EAAAC,cAACE,EAAD,CAAaC,UAAW,SAACC,GAAD,OAAWR,EAAKS,gBAAgBD,IAC5CE,cAAe,SAACjB,GAAD,OAASO,EAAKW,oBAAoBlB,IACjDJ,SAAUY,KAAKb,MAAMC,SACrBuB,kBAAmB,kBAAMZ,EAAKa,yBAE1CX,EAAAC,EAAAC,cAACU,EAAD,CAAcxB,WAAYW,KAAKb,MAAME,WACvBK,YAAaM,KAAKb,MAAMO,YACxBD,QAASO,KAAKb,MAAMM,QACpBD,IAAKQ,KAAKb,MAAMK,IAChBD,MAAOS,KAAKb,MAAMI,MAClBK,SAAUI,KAAKb,MAAMS,SACrBkB,gBAAiB,SAACC,GAAD,OAAehB,EAAKe,gBAAgBC,MAEnEd,EAAAC,EAAAC,cAAA,OAAKC,UAAU,qBACbH,EAAAC,EAAAC,cAACa,EAAAd,EAAD,CACEe,UAAQ,EACRC,OAAK,EACLC,MAAM,oBAERlB,EAAAC,EAAAC,cAACiB,EAAA,MAAD,CACEC,MAAOrB,KAAKb,MAAMW,eAClBwB,WAAY,SAACC,GAAD,OAAOxB,EAAKyB,oBAAoBD,IAC5CE,SAAU,SAACF,GAAD,OAAOxB,EAAK2B,SAAS,CAAC5B,eAAgByB,EAAEI,OAAON,YAE3DpB,EAAAC,EAAAC,cAACyB,EAAA1B,EAAD,CACEe,UAAQ,EACRb,UAAU,sBACVyB,QAAS,WACP9B,EAAK2B,SAAS,CACZtC,SAAUP,GAAQkB,EAAKZ,MAAMG,kBAAoB,GAAKT,EAAOiD,QAC7DxC,kBAAmBS,EAAKZ,MAAMG,kBAAoB,IAEpDS,EAAKgC,iBART,gBAYA9B,EAAAC,EAAAC,cAACyB,EAAA1B,EAAD,CACEe,UAAQ,EACRb,UAAU,cACVyB,QAAS,WAEPG,UAAUC,UAAUC,UAAUC,OAAOC,SAASC,QALlD,kBAUFpC,EAAAC,EAAAC,cAAA,OAAKC,UAAU,wBACbH,EAAAC,EAAAC,cAAA,yBACAF,EAAAC,EAAAC,cAAA,KAAGkC,KAAK,yJAAR,WACApC,EAAAC,EAAAC,cAAA,KAAGkC,KAAK,2VAAR,SACApC,EAAAC,EAAAC,cAAA,KAAGkC,KAAK,2VAAR,cACApC,EAAAC,EAAAC,cAAA,KAAGkC,KAAK,2VAAR,4DAOSC,EAAWC,GAGxBA,EAAUnD,SAAaY,KAAKb,MAAMC,sDAMtC,IAAMoD,EAAM,IAAIC,IAAIN,OAAOC,SAASC,MAEhCjD,EAAWoD,EAAIE,aAAaC,IAAI,OAChCvD,IACFA,EAAWwD,mBAAmBxD,GAC9BY,KAAK0B,SAAS,CAACtC,SAAUA,KAM3B,IAHA,IAAMyD,EAAgB,CAAC,KAAM,KAAM,KAAM,KAAM,MACzCC,EAAgB,GAEbC,EAAI,EAAGA,EAAIF,EAAcf,OAAQiB,IAAK,CAC7C,IAAMC,EAAQH,EAAcE,GACxBxD,EAAQiD,EAAIE,aAAaC,IAAIK,GAC7BzD,IACFA,EAAQ,IAAMA,EACduD,EAAcG,KAAK1D,IAGnBuD,EAAchB,QAChB9B,KAAK0B,SAAS,CAACrC,WAAYyD,EACzBnD,WAAYmD,EAAchB,OAAS9B,KAAKb,MAAMS,SAAWkD,EAAchB,OAAS,EAAIgB,EAAchB,OAClGpC,YAAaM,KAAKb,MAAMS,SAAWkD,EAAchB,OAASgB,EAAchB,OAAS9B,KAAKb,MAAMS,SAAW,EACvGC,SAAUG,KAAKb,MAAMS,WAAakD,EAAchB,uDAOpD,IAAMU,EAAM,IAAIC,IAAIN,OAAOC,SAASC,MACpCG,EAAIE,aAAaQ,IAAI,MAAOC,mBAAmBnD,KAAKb,MAAMC,WAC1D+C,OAAOiB,QAAQC,aAAa,CAACC,KAAKd,EAAIe,YAAY,GAAIf,EAAIe,YACvCJ,mBAAmBnD,KAAKb,MAAMC,gDAGrCI,GACZ,IAAMgD,EAAM,IAAIC,IAAIN,OAAOC,SAASC,MACpCG,EAAIE,aAAaQ,IAAI,IAAMlD,KAAKb,MAAMO,YAAY6D,WAAY/D,EAAIgE,UAAU,IAC5ErB,OAAOiB,QAAQC,aAAa,CAACC,KAAKd,EAAIe,YAAY,GAAIf,EAAIe,wDAGxChC,GACJ,UAAVA,EAAEkC,MACJzD,KAAK0B,SAAS,CACZtC,SAAUY,KAAKb,MAAMW,eACrBA,eAAgB,KAElBE,KAAK+B,uDAKPI,OAAOiB,QAAQC,aAAa,KAAM,KAAMlB,OAAOC,SAASsB,UACxD1D,KAAK0B,SAAS,CACZ/B,WAAY,EACZD,YAAa,EACbG,UAAU,EACVR,WAAY,CAAC,WAEfW,KAAKY,8DAGSL,GACd,GAAKP,KAAKb,MAAMU,SAAhB,CAGA,IAAML,EAAMmE,EAASpD,GACrBP,KAAK0B,SAAS,CAACjC,QAASD,EAAKD,MAAO,oDAGlBgB,GAClB,GAAKP,KAAKb,MAAMU,SAAhB,CAGA,IAAML,EAAMmE,EAASpD,GAIfqD,EAAa5D,KAAKb,MAAMQ,WAG9B,GAAIK,KAAKb,MAAMQ,aAAeK,KAAKb,MAAMS,SAGvC,OAFAI,KAAK0B,SAAS,CAAC7B,UAAU,SACzBG,KAAK6D,cAAcrE,GAGrBQ,KAAK6D,cAAcrE,GACnB,IAAMsE,EAAW9D,KAAKb,MAAME,WAAW0E,QAEvCD,EAASb,KAAK,SAEdjD,KAAK0B,SAAS,CAAClC,IAAK,QACND,MAAOgB,EACPb,YAAakE,EACbjE,WAAYiE,EAAa,EAAI5D,KAAKb,MAAMQ,WAAaiE,EAAa,EAAI5D,KAAKb,MAAMQ,WACjFN,WAAYyE,6CAGZE,GACdhE,KAAK0B,SAAS,CAAChC,YAAasE,EAAOnE,UAAU,WA1L/BoE,aA8LZC,6MACJC,cAAgBC,IAAMC,+FAGpBrE,KAAKsE,yDAGYhC,GACbA,EAAUlD,WAAaY,KAAKuE,MAAMnF,UACpCY,KAAKsE,oDAIK,IAAAE,EAAAxE,KACNmE,EAAgBnE,KAAKmE,cAAcM,QAClCrF,EAAYY,KAAKuE,MAAjBnF,SACDsF,EAAMP,EAAcQ,WAAW,MAC/BC,EAAQ,IAAIC,MAClBD,EAAME,OAAS,WACbJ,EAAIK,UAAU,EAAG,EAAGZ,EAAca,MAAOb,EAAcc,QADpC,IAAAC,EA6JzB,SAAgCN,EAAOO,GACrC,IAAMC,EAAcD,EAAOH,MACrBK,EAAeF,EAAOF,OACtBK,EAAaV,EAAMI,MACnBO,EAAcX,EAAMK,OAIpBO,EAAaF,EAAaC,EAE5BP,EAAQI,EACRH,EAASI,EAETG,EAJgBJ,EAAcC,EAKhCJ,EAASD,EAAQQ,EAEjBR,EAAQC,EAASO,EAEnB,MAAO,CACLR,QACAC,SACAQ,QAhBc,IAgBJL,EAAcJ,GACxBU,QAhBc,IAgBJL,EAAeJ,IA3KnBU,CAAuBf,EAAOT,GAJhCsB,EAJiBP,EAIjBO,QACAC,EALiBR,EAKjBQ,QACAV,EANiBE,EAMjBF,MACAC,EAPiBC,EAOjBD,OAGFP,EAAIkB,UAAUhB,EAAOa,EAASC,EAASV,EAAOC,GAC9CT,EAAKD,MAAM5D,qBAGbiE,EAAMiB,QAAU,WACdC,MAAM,oGAGRlB,EAAMmB,YAAc,YACpBnB,EAAMoB,IAAM5G,sCAIFmC,GACV,IAAMhB,EAAQP,KAAKiG,uBAAuB1E,GAC1CvB,KAAKuE,MAAM9D,cAAcF,2CAGXgB,GACd,IAAMhB,EAAQP,KAAKiG,uBAAuB1E,GAC1CvB,KAAKuE,MAAMjE,UAAUC,kDAGAgB,GACrB,IAAM4C,EAAgBnE,KAAKmE,cAAcM,QACnCC,EAAMP,EAAcQ,WAAW,MAE/BuB,EAAO/B,EAAcgC,wBAErBC,EAAI7E,EAAE8E,QAAUH,EAAKI,KACrBC,EAAIhF,EAAEiF,QAAUN,EAAKO,IAE3B,OAAO/B,EAAIgC,aAAaN,EAAGG,EAAG,EAAG,GAAGI,sCAG7B,IAAAC,EAAA5G,KACP,OACEC,EAAAC,EAAAC,cAAA,UAAQ0G,YAAa,SAACtF,GAAD,OAAOqF,EAAKE,gBAAgBvF,IACzCM,QAAS,SAACN,GAAD,OAAOqF,EAAKG,YAAYxF,IACjCyF,IAAKhH,KAAKmE,cACVa,MAAO,IAAMC,OAAQ,aApEThB,aAyEpBgD,6MACJC,YAAc9C,IAAMC,8FAED/B,GACbA,EAAU9C,MAAQQ,KAAKuE,MAAM/E,KAC/BQ,KAAKmH,cAEH7E,EAAU7C,UAAYO,KAAKuE,MAAM9E,SACnCO,KAAKmH,aAAY,uCAITC,GACVpH,KAAKuE,MAAMlF,WAAWW,KAAKuE,MAAM7E,aAAe0H,EAAOpH,KAAKuE,MAAM9E,QAAUO,KAAKuE,MAAM/E,qCAKvF,IAFO,IAAA6H,EAAArH,KACDsH,EAAQ,GACLvE,EAAI,EAAGA,EAAI/C,KAAKuE,MAAMlF,WAAWyC,OAAQiB,IAAK,CACrD,IAAIvD,EAAM,GACN+H,GAAQ,EACqB,UAA7BvH,KAAKuE,MAAMlF,WAAW0D,IACxBvD,EAAM,UACN+H,GAAQ,GAER/H,EAAMQ,KAAKuE,MAAMlF,WAAW0D,GAE9BuE,EAAMrE,KAAKhD,EAAAC,EAAAC,cAACqH,EAAD,CAAiBhI,IAAKA,EAAK+H,MAAOA,EAAO9D,IAAKV,EAAG0E,GAAI1E,EAAGjC,gBAAiB,SAACC,GAAD,OAAesG,EAAK9C,MAAMzD,gBAAgBC,OAEhI,OACEd,EAAAC,EAAAC,cAAA,OAAKC,UAAU,2BACZkH,UA/BkBrD,aAqCrByD,6MACJR,YAAc9C,IAAMC,8FAED/B,GAEftC,KAAKmH,0DAQPnH,KAAKuE,MAAMoD,WAAW3H,KAAKkH,YAAYzC,+CAInBzE,KAAKkH,YAAYzC,QACzBmD,MAAMC,gBAAkB7H,KAAKuE,MAAM/E,4CAOjCqI,GAKd,MAAY,KAJFA,EAAgB,GAIF,KAHdA,EAAgB,GAGU,KAF1BA,EAAgB,GAEkB,IAAO,UAAY,2CAGxD,IAAAC,EAAA9H,KAAA+H,EAQH/H,KAAKuE,MARFyD,EAAAD,EAEL3H,iBAFK,IAAA4H,EAEO,GAFPA,EAOFC,GAPEF,EAGLJ,WAHKI,EAILG,UAJKH,EAKLjH,gBALKiH,EAMLR,MANKY,OAAAC,EAAA,EAAAD,CAAAJ,EAAA,mEAUDM,EAAO,cAAAC,OAAiBtI,KAAKuE,MAAMgD,MAAQ,WAAa,GAAjD,KAAAe,OAAuDlI,GAEpE,OACEH,EAAAC,EAAAC,cAAA,MAAAgI,OAAAI,OAAA,CAAKvB,IAAKhH,KAAKkH,YAAa9G,UAAWiI,EAClCxG,QAAS,kBAAMiG,EAAKvD,MAAMzD,gBAAgBgH,EAAKvD,MAAMkD,MACjDQ,GACPhI,EAAAC,EAAAC,cAAA,QAAMC,UAAU,4BAjDA6D,aA0DlBuD,EAAkBgB,IAAWd,GAEnC,SAAS/D,EAAS8E,GAEhB,MAAO,KAAO,UADAA,EAAU,IAAM,GAAOA,EAAU,IAAM,EAAKA,EAAU,KACrClF,SAAS,IAAIQ,MAAM,GA6BrC7E,QC3YKwJ,QACW,cAA7BvG,OAAOC,SAASuG,UAEe,UAA7BxG,OAAOC,SAASuG,UAEhBxG,OAAOC,SAASuG,SAASC,MACvB,2DCZNC,IAASC,OAAO7I,EAAAC,EAAAC,cAAC4I,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBjH,WACrBA,UAAUkH,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.ef562675.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/sunset.dd77b71a.jpg\";","module.exports = __webpack_public_path__ + \"static/media/flowers.5a0c1aa2.jpg\";","module.exports = __webpack_public_path__ + \"static/media/parrots.31543aa1.jpg\";","module.exports = __webpack_public_path__ + \"static/media/island.a6b028d2.jpg\";","module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React, {Component} from 'react';\nimport Button from '@material/react-button';\nimport sunset from './images/sunset.jpg';\nimport flowers from './images/flowers.jpg';\nimport parrots from './images/parrots.jpg';\nimport island from './images/island.jpg';\nimport logo from './logo.svg';\nimport withRipple from '@material/react-ripple';\nimport TextField, {HelperText, Input} from '@material/react-text-field';\n\nimport './App.scss';\nimport { debug } from 'util';\nimport { encode } from 'punycode';\n\nconst images = [sunset, flowers, parrots, island];\n\nclass App extends Component {\n  state = {\n    imageUrl: images[0],\n    colorSwabs: ['empty'],\n    currentImageIndex: 0,\n    color: null,\n    hex: null,\n    tempHex: null,\n    currentSwab: 0,\n    totalSwabs: 1,\n    maxSwabs: 5,\n    isActive: true,\n    textFieldValue: '',\n  };\n\n  render() {\n    return (\n      <div className=\"app-container\">\n        <div className=\"color-tool-container\">\n          <ImageCanvas colorMove={(pixel) => this.handleColorMove(pixel)}\n                      colorSelected={(hex) => this.handleColorSelected(hex)} \n                      imageUrl={this.state.imageUrl}\n                      handleImageLoaded={() => this.updateImageUrlParam()}>\n          </ImageCanvas>\n          <ColorPalette colorSwabs={this.state.colorSwabs}\n                        currentSwab={this.state.currentSwab}\n                        tempHex={this.state.tempHex} \n                        hex={this.state.hex} \n                        color={this.state.color} \n                        maxSwabs={this.state.maxSwabs}\n                        handleSwabClick={(swabIndex) => this.handleSwabClick(swabIndex)}>\n          </ColorPalette>\n          <div className=\"control-container\">\n            <TextField\n              outlined\n              dense\n              label='Update Image URL'\n            >\n            <Input\n              value={this.state.textFieldValue}\n              onKeyPress={(e) => this.handleInputKeypress(e)}\n              onChange={(e) => this.setState({textFieldValue: e.target.value})}/>\n            </TextField>\n            <Button\n              outlined\n              className='random-image-button'\n              onClick={() => {\n                this.setState({\n                  imageUrl: images[(this.state.currentImageIndex + 1) % images.length],\n                  currentImageIndex: this.state.currentImageIndex + 1,\n                });\n                this.resetPallete();\n              }}>\n              Random Image\n            </Button>\n            <Button\n              outlined\n              className='copy-button'\n              onClick={() => {\n                // Probably only works in latest versions of Chrome\n                navigator.clipboard.writeText(window.location.href);\n              }}>\n              Copy Page URL\n            </Button>\n          </div>\n          <div className=\"highlighted-examples\">\n            <span>Examples:</span>\n            <a href=\"https://rlfriedman.github.io/color-picker-tool/?url=https%253A%252F%252Fi.imgur.com%252Fqbofwvx.jpg&p0=ec6762&p1=acd174&p2=3a6295&p3=514e63&p4=91baac\">Chihiro</a>\n            <a href=\"https://rlfriedman.github.io/color-picker-tool/?url=https%253A%252F%252Fimages.unsplash.com%252Fphoto-1504109586057-7a2ae83d1338%253Fixlib%253Drb-0.3.5%2526ixid%253DeyJhcHBfaWQiOjEyMDd9%2526s%253Db66e9d835de3873a86d1cec996a1af06%2526auto%253Dformat%2526fit%253Dcrop%2526w%253D2690%2526q%253D80&p0=3f7f99&p1=a1b5c8&p2=d1654e&p3=39a1a2&p4=658ea7\">Japan</a>\n            <a href=\"https://rlfriedman.github.io/color-picker-tool/?url=https%253A%252F%252Fimages.unsplash.com%252Fphoto-1508531321667-dabf317cc382%253Fixlib%253Drb-0.3.5%2526ixid%253DeyJhcHBfaWQiOjEyMDd9%2526s%253Da6181571393c9907522c562c755812b0%2526auto%253Dformat%2526fit%253Dcrop%2526w%253D2850%2526q%253D80&p0=c7ca03&p1=fdb041&p2=a55e64&p3=c40529&p4=e8c103\">Leaf Beast</a>\n            <a href=\"https://rlfriedman.github.io/color-picker-tool/?url=https%253A%252F%252Fimages.unsplash.com%252Fphoto-1532627744246-d88dcbcf9541%253Fixlib%253Drb-0.3.5%2526ixid%253DeyJhcHBfaWQiOjEyMDd9%2526s%253D3fc9ea42e8dde9b4930bf32e9db0be08%2526auto%253Dformat%2526fit%253Dcrop%2526w%253D1952%2526q%253D80&p0=d9e3ed&p1=b9c3cd&p2=7e4062&p3=bdd4ef&p4=e5e8ee\">Snow Beast</a>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    // This should not be called always but for now need to to leave the\n    // url after the palette is reset.\n    if (prevState.imageUrl !== this.state.imageUrl) {\n      //this.updateImageUrlParam();\n    }\n  }\n\n  componentWillMount() {\n    const url = new URL(window.location.href);\n   //debugger;\n    let imageUrl = url.searchParams.get('url');\n    if (imageUrl) {\n      imageUrl = decodeURIComponent(imageUrl);\n      this.setState({imageUrl: imageUrl});\n    }\n\n    const palleteParams = ['p0', 'p1', 'p2', 'p3', 'p4'];\n    const paletteColors = [];\n\n    for (let i = 0; i < palleteParams.length; i++) {\n      const param = palleteParams[i];\n      let color = url.searchParams.get(param);\n      if (color) {\n        color = '#' + color;\n        paletteColors.push(color);\n      }\n    }\n    if (paletteColors.length) {\n      this.setState({colorSwabs: paletteColors,\n        totalSwabs: paletteColors.length < this.state.maxSwabs ? paletteColors.length + 1 : paletteColors.length,\n        currentSwab: this.state.maxSwabs > paletteColors.length ? paletteColors.length : this.state.maxSwabs - 1,\n        isActive: this.state.maxSwabs !== paletteColors.length,\n        \n      })\n    }\n  }\n\n  updateImageUrlParam() {\n    const url = new URL(window.location.href);\n    url.searchParams.set('url', encodeURIComponent(this.state.imageUrl));\n    window.history.replaceState({path:url.toString()},'', url.toString());\n    const encodedUrl = encodeURIComponent(this.state.imageUrl);\n  }\n\n  addColorToUrl(hex) {\n    const url = new URL(window.location.href);\n    url.searchParams.set('p' + this.state.currentSwab.toString(), hex.substring(1));\n    window.history.replaceState({path:url.toString()},'', url.toString());\n  }\n\n  handleInputKeypress(e) {\n    if (e.key === 'Enter') {\n      this.setState({\n        imageUrl: this.state.textFieldValue,\n        textFieldValue: '',\n      });\n      this.resetPallete();\n    }\n  }\n\n  resetPallete() {\n    window.history.replaceState(null, null, window.location.pathname);\n    this.setState({\n      totalSwabs: 1,\n      currentSwab: 0,\n      isActive: true,\n      colorSwabs: [\"empty\"],\n    });\n    this.updateImageUrlParam();\n  }\n\n  handleColorMove(pixel) {\n    if (!this.state.isActive) {\n      return;\n    }\n    const hex = rgbToHex(pixel);\n    this.setState({tempHex: hex, color: null});  \n  }\n\n  handleColorSelected(pixel) {\n    if (!this.state.isActive) {\n      return;\n    }\n    const hex = rgbToHex(pixel);\n    // Consider what to do here. This will cause a new swab to be added\n    // if resetting a different swab's color. Potentially should\n    // remove 'unset' swabs when clicking on another to change it.\n    const activeSwab = this.state.totalSwabs;\n\n    // Only increment the active swab to add a new one if not at the max number.\n    if (this.state.totalSwabs === this.state.maxSwabs) {\n      this.setState({isActive: false});\n      this.addColorToUrl(hex);\n      return;\n    }\n    this.addColorToUrl(hex);\n    const newSwabs = this.state.colorSwabs.slice();\n    // Add a new swab.\n    newSwabs.push('empty');\n\n    this.setState({hex: 'empty', \n                  color: pixel, \n                  currentSwab: activeSwab,\n                  totalSwabs: activeSwab + 1 > this.state.totalSwabs ? activeSwab + 1 : this.state.totalSwabs,\n                  colorSwabs: newSwabs});\n  }\n\n  handleSwabClick(index) {\n    this.setState({currentSwab: index, isActive: true});\n  }\n}\n\nclass ImageCanvas extends Component {\n  canvasElement = React.createRef();\n\n  componentDidMount() {\n    this.updateImage();\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.imageUrl !== this.props.imageUrl) {\n      this.updateImage();\n    }\n  }\n\n  updateImage() {\n    const canvasElement = this.canvasElement.current;\n    const {imageUrl} = this.props;\n    const ctx = canvasElement.getContext('2d');\n    const image = new Image();\n    image.onload = () => {\n      ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n\n      const {\n        offsetX,\n        offsetY,\n        width,\n        height,\n      } = resizeImageToFitCanvas(image, canvasElement);\n\n      ctx.drawImage(image, offsetX, offsetY, width, height);\n      this.props.handleImageLoaded();\n    }\n\n    image.onerror = () => {\n      alert('Sorry for the alert, please try another image URL. Try a photo from imgur or the random button!');\n    }\n\n    image.crossOrigin = \"Anonymous\";\n    image.src = imageUrl;\n  }\n\n\n  handleClick(e) {\n    const pixel = this.getColorFromMouseEvent(e);\n    this.props.colorSelected(pixel);\n  }\n\n  handleMouseMove(e) {\n    const pixel = this.getColorFromMouseEvent(e);\n    this.props.colorMove(pixel);\n  }\n\n  getColorFromMouseEvent(e) {\n    const canvasElement = this.canvasElement.current;\n    const ctx = canvasElement.getContext('2d');\n    \n    const rect = canvasElement.getBoundingClientRect();\n\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    return ctx.getImageData(x, y, 1, 1).data;\n  }\n\n  render() {\n    return (\n      <canvas onMouseMove={(e) => this.handleMouseMove(e)}\n              onClick={(e) => this.handleClick(e)} \n              ref={this.canvasElement} \n              width={1000} height={500}/>\n    );\n  }\n}\n\nclass ColorPalette extends Component {\n  colorSwabEl = React.createRef();\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.hex !== this.props.hex) {\n      this.updateColor();\n    }\n    if (prevProps.tempHex !== this.props.tempHex) {\n      this.updateColor(true);\n    }\n  }\n\n  updateColor(temp) {\n    this.props.colorSwabs[this.props.currentSwab] = temp ? this.props.tempHex : this.props.hex;\n  }\n\n  render() {\n    const swabs = [];\n    for (let i = 0; i < this.props.colorSwabs.length; i++) {\n      let hex = '';\n      let empty = false;\n      if (this.props.colorSwabs[i] === 'empty') {\n        hex = '#FFFFFF';\n        empty = true;\n      } else {\n        hex = this.props.colorSwabs[i];\n      }\n      swabs.push(<RippleColorSwab hex={hex} empty={empty} key={i} id={i} handleSwabClick={(swabIndex) => this.props.handleSwabClick(swabIndex)} />);\n    }\n    return (\n      <div className=\"color-palette-container\">\n        {swabs}\n      </div>\n    );\n  }\n}\n\nclass ColorSwab extends Component {\n  colorSwabEl = React.createRef();\n\n  componentDidUpdate(prevProps) {\n   // if (prevProps.hex !== this.props.hex) {\n      this.updateColor();\n   // }\n   // if (!prevProps.hex && this.props.hex) {\n     // this.updateColor();\n   // }\n  }\n\n  componentDidMount() {\n    this.props.initRipple(this.colorSwabEl.current);\n  }\n\n  updateColor() {\n    const colorSwabEl = this.colorSwabEl.current;\n    colorSwabEl.style.backgroundColor = this.props.hex;\n\n    //const textColor = this.decideTextColor(this.props.color);\n    //colorSwabEl.style.color = textColor;\n  }\n\n  // Decides what the text color should be based on how dark the background is.\n  decideTextColor(backgroundColor) {\n    const r = backgroundColor[0];\n    const g = backgroundColor[1];\n    const b = backgroundColor[2];\n\n    return (r * 0.299 + g * 0.587 + b * 0.114 > 150) ? '#000000' : '#ffffff';\n  }\n\n  render() {\n    const {\n      className = '',\n      initRipple,\n      unbounded,\n      handleSwabClick,\n      empty,\n      ...otherProps\n    } = this.props;\n\n    const classes = `color-swab ${this.props.empty ? 'no-color' : ''} ${className}`;\n\n    return (\n      <div ref={this.colorSwabEl} className={classes}\n           onClick={() => this.props.handleSwabClick(this.props.id)}\n           {...otherProps}>\n        <span className=\"color-swab-text\">\n          {/* {this.state.hasSetColor ? this.props.hex : ''}\n          {this.props.hex ? '' : 'Select'} */}\n        </span>\n      </div>\n    );\n  }\n}\n\nconst RippleColorSwab = withRipple(ColorSwab);\n\nfunction rgbToHex(imageData) {\n  const rgb = ((imageData[0] << 16) | (imageData[1] << 8) | imageData[2]);\n  return '#' + (0x1000000 + rgb).toString(16).slice(1);\n}\n\nfunction resizeImageToFitCanvas(image, canvas) {\n  const parentWidth = canvas.width;\n  const parentHeight = canvas.height;\n  const childWidth = image.width;\n  const childHeight = image.height;\n  const offsetX = 0.5;\n  const offsetY = 0.5;\n\n  const childRatio = childWidth / childHeight\n  const parentRatio = parentWidth / parentHeight\n  let width = parentWidth;\n  let height = parentHeight;\n\n  if (childRatio < parentRatio) {\n    height = width / childRatio;\n  } else {\n    width = height * childRatio;\n  }\n  return {\n    width,\n    height,\n    offsetX: (parentWidth - width) * offsetX,\n    offsetY: (parentHeight - height) * offsetY\n  }\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}