{"version":3,"sources":["images/sunset.jpg","images/flowers.jpg","images/parrots.jpg","images/island.jpg","logo.svg","App.js","serviceWorker.js","index.js"],"names":["module","exports","__webpack_require__","p","images","sunset","flowers","parrots","island","App","state","imageUrl","colorSwabs","currentImageIndex","color","hex","tempHex","currentSwab","totalSwabs","maxSwabs","isActive","textFieldValue","_this2","this","react_default","a","createElement","className","App_ImageCanvas","colorMove","pixel","handleColorMove","colorSelected","handleColorSelected","App_ColorPalette","handleSwabClick","swabIndex","dist_default","outlined","onClick","setState","length","resetPallete","navigator","clipboard","writeText","window","location","href","react_text_field_dist_default","label","react_text_field_dist","value","onKeyPress","e","handleInputKeypress","onChange","target","prevProps","prevState","updateImageUrlParam","url","URL","searchParams","get","decodeURIComponent","palleteParams","paletteColors","i","param","push","set","encodeURIComponent","history","replaceState","path","toString","substring","key","pathname","rgbToHex","activeSwab","addColorToUrl","newSwabs","slice","index","Component","ImageCanvas","canvasElement","React","createRef","updateImage","props","current","ctx","getContext","image","Image","onload","clearRect","width","height","_resizeImageToFitCanv","canvas","parentWidth","parentHeight","childWidth","childHeight","childRatio","offsetX","offsetY","resizeImageToFitCanvas","drawImage","crossOrigin","src","getColorFromMouseEvent","rect","getBoundingClientRect","x","clientX","left","y","clientY","top","getImageData","data","_this4","onMouseMove","handleMouseMove","handleClick","ref","ColorPalette","colorSwabEl","updateColor","temp","_this6","swabs","empty","RippleColorSwab","id","ColorSwab","initRipple","style","backgroundColor","_this8","_this$props","_this$props$className","otherProps","unbounded","Object","objectWithoutProperties","classes","concat","assign","withRipple","imageData","Boolean","hostname","match","ReactDOM","render","src_App_0","document","getElementById","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.0354e87c.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/sunset.dd77b71a.jpg\";","module.exports = __webpack_public_path__ + \"static/media/flowers.5a0c1aa2.jpg\";","module.exports = __webpack_public_path__ + \"static/media/parrots.31543aa1.jpg\";","module.exports = __webpack_public_path__ + \"static/media/island.a6b028d2.jpg\";","module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React, {Component} from 'react';\nimport Button from '@material/react-button';\nimport sunset from './images/sunset.jpg';\nimport flowers from './images/flowers.jpg';\nimport parrots from './images/parrots.jpg';\nimport island from './images/island.jpg';\nimport logo from './logo.svg';\nimport withRipple from '@material/react-ripple';\nimport TextField, {HelperText, Input} from '@material/react-text-field';\n\nimport './App.scss';\nimport { debug } from 'util';\nimport { encode } from 'punycode';\n\nconst images = [sunset, flowers, parrots, island];\n\nclass App extends Component {\n  state = {\n    imageUrl: images[0],\n    colorSwabs: ['empty'],\n    currentImageIndex: 0,\n    color: null,\n    hex: null,\n    tempHex: null,\n    currentSwab: 0,\n    totalSwabs: 1,\n    maxSwabs: 5,\n    isActive: true,\n    textFieldValue: '',\n  };\n\n  render() {\n    return (\n      <div className=\"app-container\">\n        <div className=\"color-tool-container\">\n          <ImageCanvas colorMove={(pixel) => this.handleColorMove(pixel)}\n                      colorSelected={(hex) => this.handleColorSelected(hex)} \n                      imageUrl={this.state.imageUrl}>\n          </ImageCanvas>\n          <ColorPalette colorSwabs={this.state.colorSwabs}\n                        currentSwab={this.state.currentSwab}\n                        tempHex={this.state.tempHex} \n                        hex={this.state.hex} \n                        color={this.state.color} \n                        maxSwabs={this.state.maxSwabs}\n                        handleSwabClick={(swabIndex) => this.handleSwabClick(swabIndex)}>\n          </ColorPalette>\n          <div className=\"control-container\">\n            <Button\n              outlined\n              className='random-image-button'\n              onClick={() => {\n                this.setState({\n                  imageUrl: images[(this.state.currentImageIndex + 1) % images.length],\n                  currentImageIndex: this.state.currentImageIndex + 1,\n                });\n                this.resetPallete();\n              }}>\n              Random Image\n            </Button>\n            <Button\n              outlined\n              className='random-image-button'\n              onClick={() => {\n                // Probably only works in latest versions of Chrome\n                navigator.clipboard.writeText(window.location.href);\n              }}>\n              Copy URL\n            </Button>\n            <TextField\n              outlined\n              label='Update Image URL'\n            >\n            <Input\n              value={this.state.textFieldValue}\n              onKeyPress={(e) => this.handleInputKeypress(e)}\n              onChange={(e) => this.setState({textFieldValue: e.target.value})}/>\n            </TextField>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    // This should not be called always but for now need to to leave the\n    // url after the palette is reset.\n    if (prevState.imageUrl !== this.state.imageUrl) {\n      this.updateImageUrlParam();\n    }\n  }\n\n  componentWillMount() {\n    const url = new URL(window.location.href);\n   //debugger;\n    let imageUrl = url.searchParams.get('url');\n    if (imageUrl) {\n      imageUrl = decodeURIComponent(imageUrl);\n      this.setState({imageUrl: imageUrl});\n    }\n\n    const palleteParams = ['p0', 'p1', 'p2', 'p3', 'p4'];\n    const paletteColors = [];\n\n    for (let i = 0; i < palleteParams.length; i++) {\n      const param = palleteParams[i];\n      let color = url.searchParams.get(param);\n      if (color) {\n        color = '#' + color;\n        paletteColors.push(color);\n      }\n    }\n    if (paletteColors.length) {\n      this.setState({colorSwabs: paletteColors,\n        totalSwabs: paletteColors.length,\n        currentSwab: this.state.maxSwabs > paletteColors.length ? paletteColors.length : this.state.maxSwabs - 1,\n        isActive: this.state.maxSwabs !== paletteColors.length,\n        \n      })\n    }\n  }\n\n  updateImageUrlParam() {\n    const url = new URL(window.location.href);\n    url.searchParams.set('url', encodeURIComponent(this.state.imageUrl));\n    window.history.replaceState({path:url.toString()},'', url.toString());\n    const encodedUrl = encodeURIComponent(this.state.imageUrl);\n  }\n\n  addColorToUrl(hex) {\n    const url = new URL(window.location.href);\n    url.searchParams.set('p' + this.state.currentSwab.toString(), hex.substring(1));\n    window.history.replaceState({path:url.toString()},'', url.toString());\n  }\n\n  handleInputKeypress(e) {\n    if (e.key === 'Enter') {\n      this.setState({\n        imageUrl: this.state.textFieldValue,\n        textFieldValue: '',\n      });\n      this.resetPallete();\n    }\n  }\n\n  resetPallete() {\n    window.history.replaceState(null, null, window.location.pathname);\n    this.setState({\n      totalSwabs: 1,\n      currentSwab: 0,\n      isActive: true,\n      colorSwabs: [\"empty\"],\n    });\n    this.updateImageUrlParam();\n  }\n\n  handleColorMove(pixel) {\n    if (!this.state.isActive) {\n      return;\n    }\n    const hex = rgbToHex(pixel);\n    this.setState({tempHex: hex, color: null});  \n  }\n\n  handleColorSelected(pixel) {\n    if (!this.state.isActive) {\n      return;\n    }\n    const hex = rgbToHex(pixel);\n    // Consider what to do here. This will cause a new swab to be added\n    // if resetting a different swab's color. Potentially should\n    // remove 'unset' swabs when clicking on another to change it.\n    const activeSwab = this.state.totalSwabs;\n\n    // Only increment the active swab to add a new one if not at the max number.\n    if (this.state.totalSwabs === this.state.maxSwabs) {\n      this.setState({isActive: false});\n      this.addColorToUrl(hex);\n      return;\n    }\n    this.addColorToUrl(hex);\n    const newSwabs = this.state.colorSwabs.slice();\n    // Add a new swab.\n    newSwabs.push('empty');\n\n    this.setState({hex: 'empty', \n                  color: pixel, \n                  currentSwab: activeSwab,\n                  totalSwabs: activeSwab + 1 > this.state.totalSwabs ? activeSwab + 1 : this.state.totalSwabs,\n                  colorSwabs: newSwabs});\n  }\n\n  handleSwabClick(index) {\n    this.setState({currentSwab: index, isActive: true});\n  }\n}\n\nclass ImageCanvas extends Component {\n  canvasElement = React.createRef();\n\n  componentDidMount() {\n    this.updateImage();\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.imageUrl !== this.props.imageUrl) {\n      this.updateImage();\n    }\n  }\n\n  updateImage() {\n    const canvasElement = this.canvasElement.current;\n    const {imageUrl} = this.props;\n    const ctx = canvasElement.getContext('2d');\n    const image = new Image();\n    image.onload = () => {\n      ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n\n      const {\n        offsetX,\n        offsetY,\n        width,\n        height,\n      } = resizeImageToFitCanvas(image, canvasElement);\n\n      ctx.drawImage(image, offsetX, offsetY, width, height);\n    }\n    image.crossOrigin = \"Anonymous\";\n    image.src = imageUrl;\n  }\n\n\n  handleClick(e) {\n    const pixel = this.getColorFromMouseEvent(e);\n    this.props.colorSelected(pixel);\n  }\n\n  handleMouseMove(e) {\n    const pixel = this.getColorFromMouseEvent(e);\n    this.props.colorMove(pixel);\n  }\n\n  getColorFromMouseEvent(e) {\n    const canvasElement = this.canvasElement.current;\n    const ctx = canvasElement.getContext('2d');\n    \n    const rect = canvasElement.getBoundingClientRect();\n\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    return ctx.getImageData(x, y, 1, 1).data;\n  }\n\n  render() {\n    return (\n      <canvas onMouseMove={(e) => this.handleMouseMove(e)}\n              onClick={(e) => this.handleClick(e)} \n              ref={this.canvasElement} \n              width={1000} height={500}/>\n    );\n  }\n}\n\nclass ColorPalette extends Component {\n  colorSwabEl = React.createRef();\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.hex !== this.props.hex) {\n      this.updateColor();\n    }\n    if (prevProps.tempHex !== this.props.tempHex) {\n      this.updateColor(true);\n    }\n  }\n\n  updateColor(temp) {\n    this.props.colorSwabs[this.props.currentSwab] = temp ? this.props.tempHex : this.props.hex;\n  }\n\n  render() {\n    const swabs = [];\n    for (let i = 0; i < this.props.colorSwabs.length; i++) {\n      let hex = '';\n      let empty = false;\n      if (this.props.colorSwabs[i] === 'empty') {\n        hex = '#FFFFFF';\n        empty = true;\n      } else {\n        hex = this.props.colorSwabs[i];\n      }\n      swabs.push(<RippleColorSwab hex={hex} empty={empty} key={i} id={i} handleSwabClick={(swabIndex) => this.props.handleSwabClick(swabIndex)} />);\n    }\n    return (\n      <div className=\"color-palette-container\">\n        {swabs}\n      </div>\n    );\n  }\n}\n\nclass ColorSwab extends Component {\n  colorSwabEl = React.createRef();\n\n  componentDidUpdate(prevProps) {\n   // if (prevProps.hex !== this.props.hex) {\n      this.updateColor();\n   // }\n   // if (!prevProps.hex && this.props.hex) {\n     // this.updateColor();\n   // }\n  }\n\n  componentDidMount() {\n    this.props.initRipple(this.colorSwabEl.current);\n  }\n\n  updateColor() {\n    const colorSwabEl = this.colorSwabEl.current;\n    colorSwabEl.style.backgroundColor = this.props.hex;\n\n    //const textColor = this.decideTextColor(this.props.color);\n    //colorSwabEl.style.color = textColor;\n  }\n\n  // Decides what the text color should be based on how dark the background is.\n  decideTextColor(backgroundColor) {\n    const r = backgroundColor[0];\n    const g = backgroundColor[1];\n    const b = backgroundColor[2];\n\n    return (r * 0.299 + g * 0.587 + b * 0.114 > 150) ? '#000000' : '#ffffff';\n  }\n\n  render() {\n    const {\n      className = '',\n      initRipple,\n      unbounded,\n      handleSwabClick,\n      empty,\n      ...otherProps\n    } = this.props;\n\n    const classes = `color-swab ${this.props.empty ? 'no-color' : ''} ${className}`;\n\n    return (\n      <div ref={this.colorSwabEl} className={classes}\n           onClick={() => this.props.handleSwabClick(this.props.id)}\n           {...otherProps}>\n        <span className=\"color-swab-text\">\n          {/* {this.state.hasSetColor ? this.props.hex : ''}\n          {this.props.hex ? '' : 'Select'} */}\n        </span>\n      </div>\n    );\n  }\n}\n\nconst RippleColorSwab = withRipple(ColorSwab);\n\nfunction rgbToHex(imageData) {\n  const rgb = ((imageData[0] << 16) | (imageData[1] << 8) | imageData[2]);\n  return '#' + (0x1000000 + rgb).toString(16).slice(1);\n}\n\nfunction resizeImageToFitCanvas(image, canvas) {\n  const parentWidth = canvas.width;\n  const parentHeight = canvas.height;\n  const childWidth = image.width;\n  const childHeight = image.height;\n  const offsetX = 0.5;\n  const offsetY = 0.5;\n\n  const childRatio = childWidth / childHeight\n  const parentRatio = parentWidth / parentHeight\n  let width = parentWidth;\n  let height = parentHeight;\n\n  if (childRatio < parentRatio) {\n    height = width / childRatio;\n  } else {\n    width = height * childRatio;\n  }\n  return {\n    width,\n    height,\n    offsetX: (parentWidth - width) * offsetX,\n    offsetY: (parentHeight - height) * offsetY\n  }\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}